{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyFunction = exports.lazyObject = void 0;\n\nvar util_1 = __importDefault(require(\"util\"));\n\nvar errors_1 = require(\"../core/errors\");\n\nvar errors_list_1 = require(\"../core/errors-list\");\n\nvar inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nfunction lazyObject(objectCreator) {\n  return createLazyProxy(objectCreator, function (getRealTarget) {\n    return _defineProperty({}, inspect, function (depth, options) {\n      var inspectFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : util_1.default.inspect;\n      var realTarget = getRealTarget();\n      var newOptions = Object.assign(Object.assign({}, options), {\n        depth: depth\n      });\n      return inspectFn(realTarget, newOptions);\n    });\n  }, function (object) {\n    if (object instanceof Function) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Creating lazy functions or classes with lazyObject\"\n      });\n    }\n\n    if (typeof object !== \"object\" || object === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyObject with anything other than objects\"\n      });\n    }\n  });\n}\n\nexports.lazyObject = lazyObject; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction lazyFunction(functionCreator) {\n  return createLazyProxy(functionCreator, function (getRealTarget) {\n    function dummyTarget() {}\n\n    dummyTarget[inspect] = function (depth, options) {\n      var inspectFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : util_1.default.inspect;\n      var realTarget = getRealTarget();\n      var newOptions = Object.assign(Object.assign({}, options), {\n        depth: depth\n      });\n      return inspectFn(realTarget, newOptions);\n    };\n\n    return dummyTarget;\n  }, function (object) {\n    if (!(object instanceof Function)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyFunction with anything other than functions or classes\"\n      });\n    }\n  });\n}\n\nexports.lazyFunction = lazyFunction;\n\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n  var realTarget;\n  var dummyTarget = dummyTargetCreator(getRealTarget);\n\n  function getRealTarget() {\n    if (realTarget === undefined) {\n      var target = targetCreator();\n      validator(target); // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n\n      var properties = Object.getOwnPropertyNames(target);\n\n      var _iterator = _createForOfIteratorHelper(properties),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var property = _step.value;\n          var descriptor = Object.getOwnPropertyDescriptor(target, property);\n          Object.defineProperty(dummyTarget, property, descriptor);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target)); // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n\n      if (Object.getPrototypeOf(target) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\"\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  var handler = {\n    defineProperty: function defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n    deleteProperty: function deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n    get: function get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      var stack = new Error().stack;\n\n      if (stack !== undefined && stack.includes(\"givenProvider.js\") && realTarget === undefined) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, property) {\n      var descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n    getPrototypeOf: function getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n    has: function has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n    isExtensible: function isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n    ownKeys: function ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n    preventExtensions: function preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n    set: function set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n    setPrototypeOf: function setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    }\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = function (target, thisArg, argArray) {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget(), thisArg, argArray);\n    };\n\n    handler.construct = function (target, argArray, _newTarget) {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget(), argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}","map":null,"metadata":{},"sourceType":"script"}