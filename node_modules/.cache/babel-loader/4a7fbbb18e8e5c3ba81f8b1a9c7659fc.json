{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertHardhatInvariant = exports.applyErrorMessageTemplate = exports.NomicLabsHardhatPluginError = exports.HardhatPluginError = exports.HardhatError = exports.CustomError = void 0;\n\nvar caller_package_1 = require(\"../util/caller-package\");\n\nvar strings_1 = require(\"../util/strings\");\n\nvar errors_list_1 = require(\"./errors-list\");\n\nvar inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nvar CustomError = /*#__PURE__*/function (_Error) {\n  _inherits(CustomError, _Error);\n\n  function CustomError(message, parent) {\n    var _this;\n\n    _classCallCheck(this, CustomError);\n\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CustomError).call(this, message));\n    _this.parent = parent;\n    _this.name = _this.constructor.name; // We do this to avoid including the constructor in the stack trace\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    }\n\n    return _this;\n  }\n\n  _createClass(CustomError, [{\n    key: inspect,\n    value: function value() {\n      var _a, _b, _c, _d, _e;\n\n      var str = this.stack;\n\n      if (this.parent !== undefined) {\n        var parentAsAny = this.parent;\n        var causeString = (_e = (_d = (_b = (_a = parentAsAny[inspect]) === null || _a === void 0 ? void 0 : _a.call(parentAsAny)) !== null && _b !== void 0 ? _b : (_c = parentAsAny.inspect) === null || _c === void 0 ? void 0 : _c.call(parentAsAny)) !== null && _d !== void 0 ? _d : parentAsAny.stack) !== null && _e !== void 0 ? _e : parentAsAny.toString();\n        var nestedCauseStr = causeString.split(\"\\n\").map(function (line) {\n          return \"    \".concat(line);\n        }).join(\"\\n\").trim();\n        str += \"\\n\\n    Caused by: \".concat(nestedCauseStr);\n      }\n\n      return str;\n    }\n  }]);\n\n  return CustomError;\n}(_wrapNativeSuper(Error));\n\nexports.CustomError = CustomError;\n\nvar HardhatError = /*#__PURE__*/function (_CustomError) {\n  _inherits(HardhatError, _CustomError);\n\n  function HardhatError(errorDescriptor) {\n    var _this2;\n\n    var messageArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var parentError = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, HardhatError);\n\n    var prefix = \"\".concat((0, errors_list_1.getErrorCode)(errorDescriptor), \": \");\n    var formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(HardhatError).call(this, prefix + formattedMessage, parentError));\n    _this2.errorDescriptor = errorDescriptor;\n    _this2.number = errorDescriptor.number;\n    _this2.messageArguments = messageArguments;\n    _this2._isHardhatError = true;\n    Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this2)), HardhatError.prototype);\n    return _this2;\n  }\n\n  _createClass(HardhatError, null, [{\n    key: \"isHardhatError\",\n    value: function isHardhatError(other) {\n      return other !== undefined && other !== null && other._isHardhatError === true;\n    }\n  }, {\n    key: \"isHardhatErrorType\",\n    value: function isHardhatErrorType(other, descriptor) {\n      return HardhatError.isHardhatError(other) && other.errorDescriptor.number === descriptor.number;\n    }\n  }]);\n\n  return HardhatError;\n}(CustomError);\n\nexports.HardhatError = HardhatError;\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\n\nvar HardhatPluginError = /*#__PURE__*/function (_CustomError2) {\n  _inherits(HardhatPluginError, _CustomError2);\n\n  function HardhatPluginError(pluginNameOrMessage, messageOrParent, parent) {\n    var _this3;\n\n    _classCallCheck(this, HardhatPluginError);\n\n    if (typeof messageOrParent === \"string\") {\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(HardhatPluginError).call(this, messageOrParent, parent));\n      _this3.pluginName = pluginNameOrMessage;\n    } else {\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(HardhatPluginError).call(this, pluginNameOrMessage, messageOrParent));\n      _this3.pluginName = (0, caller_package_1.getClosestCallerPackage)();\n    }\n\n    _this3._isHardhatPluginError = true;\n    Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this3)), HardhatPluginError.prototype);\n    return _possibleConstructorReturn(_this3);\n  }\n\n  _createClass(HardhatPluginError, null, [{\n    key: \"isHardhatPluginError\",\n    value: function isHardhatPluginError(other) {\n      return other !== undefined && other !== null && other._isHardhatPluginError === true;\n    }\n  }]);\n\n  return HardhatPluginError;\n}(CustomError);\n\nexports.HardhatPluginError = HardhatPluginError;\n\nvar NomicLabsHardhatPluginError = /*#__PURE__*/function (_HardhatPluginError) {\n  _inherits(NomicLabsHardhatPluginError, _HardhatPluginError);\n\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  function NomicLabsHardhatPluginError(pluginName, message, parent) {\n    var _this4;\n\n    var shouldBeReported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, NomicLabsHardhatPluginError);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(NomicLabsHardhatPluginError).call(this, pluginName, message, parent));\n    _this4.shouldBeReported = shouldBeReported;\n    _this4._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this4)), NomicLabsHardhatPluginError.prototype);\n    return _this4;\n  }\n\n  _createClass(NomicLabsHardhatPluginError, null, [{\n    key: \"isNomicLabsHardhatPluginError\",\n    value: function isNomicLabsHardhatPluginError(other) {\n      return other !== undefined && other !== null && other._isNomicLabsHardhatPluginError === true;\n    }\n  }]);\n\n  return NomicLabsHardhatPluginError;\n}(HardhatPluginError);\n\nexports.NomicLabsHardhatPluginError = NomicLabsHardhatPluginError;\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\n\nfunction applyErrorMessageTemplate(template, values) {\n  return _applyErrorMessageTemplate(template, values, false);\n}\n\nexports.applyErrorMessageTemplate = applyErrorMessageTemplate;\n\nfunction _applyErrorMessageTemplate(template, values, isRecursiveCall) {\n  if (!isRecursiveCall) {\n    for (var _i = 0, _Object$keys = Object.keys(values); _i < _Object$keys.length; _i++) {\n      var variableName = _Object$keys[_i];\n\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName\n        });\n      }\n\n      var variableTag = \"%\".concat(variableName, \"%\");\n\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName\n        });\n      }\n    }\n  }\n\n  if (template.includes(\"%%\")) {\n    return template.split(\"%%\").map(function (part) {\n      return _applyErrorMessageTemplate(part, values, true);\n    }).join(\"%\");\n  }\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(values); _i2 < _Object$keys2.length; _i2++) {\n    var _variableName = _Object$keys2[_i2];\n    var value = void 0;\n\n    if (values[_variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[_variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[_variableName].toString();\n    }\n\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n\n    var _variableTag = \"%\".concat(_variableName, \"%\");\n\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG, {\n        variable: _variableName\n      });\n    }\n\n    template = (0, strings_1.replaceAll)(template, _variableTag, value);\n  }\n\n  return template;\n}\n\nfunction assertHardhatInvariant(invariant, message) {\n  if (!invariant) {\n    throw new HardhatError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, {\n      message: message\n    });\n  }\n}\n\nexports.assertHardhatInvariant = assertHardhatInvariant;","map":null,"metadata":{},"sourceType":"script"}