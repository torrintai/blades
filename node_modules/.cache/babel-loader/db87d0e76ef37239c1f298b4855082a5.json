{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/home/loar/react-multi/rh-verse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContractAtFromArtifact = exports.getContractAt = exports.getContractFactoryFromArtifact = exports.getContractFactory = exports.getImpersonatedSigner = exports.getSigner = exports.getSigners = void 0;\n\nvar plugins_1 = require(\"hardhat/plugins\");\n\nvar pluginName = \"hardhat-ethers\";\n\nfunction isArtifact(artifact) {\n  var contractName = artifact.contractName,\n      sourceName = artifact.sourceName,\n      abi = artifact.abi,\n      bytecode = artifact.bytecode,\n      deployedBytecode = artifact.deployedBytecode,\n      linkReferences = artifact.linkReferences,\n      deployedLinkReferences = artifact.deployedLinkReferences;\n  return typeof contractName === \"string\" && typeof sourceName === \"string\" && Array.isArray(abi) && typeof bytecode === \"string\" && typeof deployedBytecode === \"string\" && linkReferences !== undefined && deployedLinkReferences !== undefined;\n}\n\nfunction getSigners(_x) {\n  return _getSigners.apply(this, arguments);\n}\n\nfunction _getSigners() {\n  _getSigners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hre) {\n    var accounts, signersWithAddress;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return hre.ethers.provider.listAccounts();\n\n          case 2:\n            accounts = _context.sent;\n            _context.next = 5;\n            return Promise.all(accounts.map(function (account) {\n              return getSigner(hre, account);\n            }));\n\n          case 5:\n            signersWithAddress = _context.sent;\n            return _context.abrupt(\"return\", signersWithAddress);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getSigners.apply(this, arguments);\n}\n\nexports.getSigners = getSigners;\n\nfunction getSigner(_x2, _x3) {\n  return _getSigner.apply(this, arguments);\n}\n\nfunction _getSigner() {\n  _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hre, address) {\n    var _yield$Promise$resolv, SignerWithAddressImpl, signer, signerWithAddress;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return Promise.resolve().then(function () {\n              return __importStar(require(\"../signers\"));\n            });\n\n          case 2:\n            _yield$Promise$resolv = _context2.sent;\n            SignerWithAddressImpl = _yield$Promise$resolv.SignerWithAddress;\n            signer = hre.ethers.provider.getSigner(address);\n            _context2.next = 7;\n            return SignerWithAddressImpl.create(signer);\n\n          case 7:\n            signerWithAddress = _context2.sent;\n            return _context2.abrupt(\"return\", signerWithAddress);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSigner.apply(this, arguments);\n}\n\nexports.getSigner = getSigner;\n\nfunction getImpersonatedSigner(_x4, _x5) {\n  return _getImpersonatedSigner.apply(this, arguments);\n}\n\nfunction _getImpersonatedSigner() {\n  _getImpersonatedSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(hre, address) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return hre.ethers.provider.send(\"hardhat_impersonateAccount\", [address]);\n\n          case 2:\n            return _context3.abrupt(\"return\", getSigner(hre, address));\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getImpersonatedSigner.apply(this, arguments);\n}\n\nexports.getImpersonatedSigner = getImpersonatedSigner;\n\nfunction getContractFactory(_x6, _x7, _x8, _x9) {\n  return _getContractFactory.apply(this, arguments);\n}\n\nfunction _getContractFactory() {\n  _getContractFactory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(hre, nameOrAbi, bytecodeOrFactoryOptions, signer) {\n    var artifact;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(typeof nameOrAbi === \"string\")) {\n              _context4.next = 5;\n              break;\n            }\n\n            _context4.next = 3;\n            return hre.artifacts.readArtifact(nameOrAbi);\n\n          case 3:\n            artifact = _context4.sent;\n            return _context4.abrupt(\"return\", getContractFactoryFromArtifact(hre, artifact, bytecodeOrFactoryOptions));\n\n          case 5:\n            return _context4.abrupt(\"return\", getContractFactoryByAbiAndBytecode(hre, nameOrAbi, bytecodeOrFactoryOptions, signer));\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getContractFactory.apply(this, arguments);\n}\n\nexports.getContractFactory = getContractFactory;\n\nfunction isFactoryOptions(signerOrOptions) {\n  var _require = require(\"ethers\"),\n      Signer = _require.Signer;\n\n  if (signerOrOptions === undefined || signerOrOptions instanceof Signer) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getContractFactoryFromArtifact(_x10, _x11, _x12) {\n  return _getContractFactoryFromArtifact.apply(this, arguments);\n}\n\nfunction _getContractFactoryFromArtifact() {\n  _getContractFactoryFromArtifact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(hre, artifact, signerOrOptions) {\n    var _a, libraries, signer, linkedBytecode;\n\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            libraries = {};\n\n            if (isArtifact(artifact)) {\n              _context5.next = 3;\n              break;\n            }\n\n            throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"You are trying to create a contract factory from an artifact, but you have not passed a valid artifact parameter.\");\n\n          case 3:\n            if (isFactoryOptions(signerOrOptions)) {\n              signer = signerOrOptions.signer;\n              libraries = (_a = signerOrOptions.libraries) !== null && _a !== void 0 ? _a : {};\n            } else {\n              signer = signerOrOptions;\n            }\n\n            if (!(artifact.bytecode === \"0x\")) {\n              _context5.next = 6;\n              break;\n            }\n\n            throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"You are trying to create a contract factory for the contract \".concat(artifact.contractName, \", which is abstract and can't be deployed.\\nIf you want to call a contract using \").concat(artifact.contractName, \" as its interface use the \\\"getContractAt\\\" function instead.\"));\n\n          case 6:\n            _context5.next = 8;\n            return collectLibrariesAndLink(artifact, libraries);\n\n          case 8:\n            linkedBytecode = _context5.sent;\n            return _context5.abrupt(\"return\", getContractFactoryByAbiAndBytecode(hre, artifact.abi, linkedBytecode, signer));\n\n          case 10:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getContractFactoryFromArtifact.apply(this, arguments);\n}\n\nexports.getContractFactoryFromArtifact = getContractFactoryFromArtifact;\n\nfunction collectLibrariesAndLink(_x13, _x14) {\n  return _collectLibrariesAndLink.apply(this, arguments);\n}\n\nfunction _collectLibrariesAndLink() {\n  _collectLibrariesAndLink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(artifact, libraries) {\n    var _require3, utils, neededLibraries, _i, _Object$entries, _Object$entries$_i, sourceName, sourceLibraries, _i2, _Object$keys, libName, linksToApply, _loop, _i3, _Object$entries2, missingLibraries;\n\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _require3 = require(\"ethers\"), utils = _require3.utils;\n            neededLibraries = [];\n\n            for (_i = 0, _Object$entries = Object.entries(artifact.linkReferences); _i < _Object$entries.length; _i++) {\n              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), sourceName = _Object$entries$_i[0], sourceLibraries = _Object$entries$_i[1];\n\n              for (_i2 = 0, _Object$keys = Object.keys(sourceLibraries); _i2 < _Object$keys.length; _i2++) {\n                libName = _Object$keys[_i2];\n                neededLibraries.push({\n                  sourceName: sourceName,\n                  libName: libName\n                });\n              }\n            }\n\n            linksToApply = new Map();\n\n            _loop = function _loop() {\n              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n                  linkedLibraryName = _Object$entries2$_i[0],\n                  linkedLibraryAddress = _Object$entries2$_i[1];\n\n              if (!utils.isAddress(linkedLibraryAddress)) {\n                throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"You tried to link the contract \".concat(artifact.contractName, \" with the library \").concat(linkedLibraryName, \", but provided this invalid address: \").concat(linkedLibraryAddress));\n              }\n\n              var matchingNeededLibraries = neededLibraries.filter(function (lib) {\n                return lib.libName === linkedLibraryName || \"\".concat(lib.sourceName, \":\").concat(lib.libName) === linkedLibraryName;\n              });\n\n              if (matchingNeededLibraries.length === 0) {\n                var detailedMessage;\n\n                if (neededLibraries.length > 0) {\n                  var libraryFQNames = neededLibraries.map(function (lib) {\n                    return \"\".concat(lib.sourceName, \":\").concat(lib.libName);\n                  }).map(function (x) {\n                    return \"* \".concat(x);\n                  }).join(\"\\n\");\n                  detailedMessage = \"The libraries needed are:\\n\".concat(libraryFQNames);\n                } else {\n                  detailedMessage = \"This contract doesn't need linking any libraries.\";\n                }\n\n                throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"You tried to link the contract \".concat(artifact.contractName, \" with \").concat(linkedLibraryName, \", which is not one of its libraries.\\n\").concat(detailedMessage));\n              }\n\n              if (matchingNeededLibraries.length > 1) {\n                var matchingNeededLibrariesFQNs = matchingNeededLibraries.map(function (_ref) {\n                  var sourceName = _ref.sourceName,\n                      libName = _ref.libName;\n                  return \"\".concat(sourceName, \":\").concat(libName);\n                }).map(function (x) {\n                  return \"* \".concat(x);\n                }).join(\"\\n\");\n                throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"The library name \".concat(linkedLibraryName, \" is ambiguous for the contract \").concat(artifact.contractName, \".\\nIt may resolve to one of the following libraries:\\n\").concat(matchingNeededLibrariesFQNs, \"\\n\\nTo fix this, choose one of these fully qualified library names and replace where appropriate.\"));\n              }\n\n              var _matchingNeededLibrar = _slicedToArray(matchingNeededLibraries, 1),\n                  neededLibrary = _matchingNeededLibrar[0];\n\n              var neededLibraryFQN = \"\".concat(neededLibrary.sourceName, \":\").concat(neededLibrary.libName); // The only way for this library to be already mapped is\n              // for it to be given twice in the libraries user input:\n              // once as a library name and another as a fully qualified library name.\n\n              if (linksToApply.has(neededLibraryFQN)) {\n                throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"The library names \".concat(neededLibrary.libName, \" and \").concat(neededLibraryFQN, \" refer to the same library and were given as two separate library links.\\nRemove one of them and review your library links before proceeding.\"));\n              }\n\n              linksToApply.set(neededLibraryFQN, {\n                sourceName: neededLibrary.sourceName,\n                libraryName: neededLibrary.libName,\n                address: linkedLibraryAddress\n              });\n            };\n\n            for (_i3 = 0, _Object$entries2 = Object.entries(libraries); _i3 < _Object$entries2.length; _i3++) {\n              _loop();\n            }\n\n            if (!(linksToApply.size < neededLibraries.length)) {\n              _context6.next = 9;\n              break;\n            }\n\n            missingLibraries = neededLibraries.map(function (lib) {\n              return \"\".concat(lib.sourceName, \":\").concat(lib.libName);\n            }).filter(function (libFQName) {\n              return !linksToApply.has(libFQName);\n            }).map(function (x) {\n              return \"* \".concat(x);\n            }).join(\"\\n\");\n            throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"The contract \".concat(artifact.contractName, \" is missing links for the following libraries:\\n\").concat(missingLibraries, \"\\n\\nLearn more about linking contracts at https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-ethers#library-linking\\n\"));\n\n          case 9:\n            return _context6.abrupt(\"return\", linkBytecode(artifact, _toConsumableArray(linksToApply.values())));\n\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _collectLibrariesAndLink.apply(this, arguments);\n}\n\nfunction getContractFactoryByAbiAndBytecode(_x15, _x16, _x17, _x18) {\n  return _getContractFactoryByAbiAndBytecode.apply(this, arguments);\n}\n\nfunction _getContractFactoryByAbiAndBytecode() {\n  _getContractFactoryByAbiAndBytecode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(hre, abi, bytecode, signer) {\n    var _require4, ContractFactory, signers, abiWithAddedGas;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _require4 = require(\"ethers\"), ContractFactory = _require4.ContractFactory;\n\n            if (!(signer === undefined)) {\n              _context7.next = 6;\n              break;\n            }\n\n            _context7.next = 4;\n            return hre.ethers.getSigners();\n\n          case 4:\n            signers = _context7.sent;\n            signer = signers[0];\n\n          case 6:\n            abiWithAddedGas = addGasToAbiMethodsIfNecessary(hre.network.config, abi);\n            return _context7.abrupt(\"return\", new ContractFactory(abiWithAddedGas, bytecode, signer));\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _getContractFactoryByAbiAndBytecode.apply(this, arguments);\n}\n\nfunction getContractAt(_x19, _x20, _x21, _x22) {\n  return _getContractAt.apply(this, arguments);\n}\n\nfunction _getContractAt() {\n  _getContractAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(hre, nameOrAbi, address, signer) {\n    var artifact, _require5, Contract, signers, signerOrProvider, abiWithAddedGas;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(typeof nameOrAbi === \"string\")) {\n              _context8.next = 5;\n              break;\n            }\n\n            _context8.next = 3;\n            return hre.artifacts.readArtifact(nameOrAbi);\n\n          case 3:\n            artifact = _context8.sent;\n            return _context8.abrupt(\"return\", getContractAtFromArtifact(hre, artifact, address, signer));\n\n          case 5:\n            _require5 = require(\"ethers\"), Contract = _require5.Contract;\n\n            if (!(signer === undefined)) {\n              _context8.next = 11;\n              break;\n            }\n\n            _context8.next = 9;\n            return hre.ethers.getSigners();\n\n          case 9:\n            signers = _context8.sent;\n            signer = signers[0];\n\n          case 11:\n            // If there's no signer, we want to put the provider for the selected network here.\n            // This allows read only operations on the contract interface.\n            signerOrProvider = signer !== undefined ? signer : hre.ethers.provider;\n            abiWithAddedGas = addGasToAbiMethodsIfNecessary(hre.network.config, nameOrAbi);\n            return _context8.abrupt(\"return\", new Contract(address, abiWithAddedGas, signerOrProvider));\n\n          case 14:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _getContractAt.apply(this, arguments);\n}\n\nexports.getContractAt = getContractAt;\n\nfunction getContractAtFromArtifact(_x23, _x24, _x25, _x26) {\n  return _getContractAtFromArtifact.apply(this, arguments);\n}\n\nfunction _getContractAtFromArtifact() {\n  _getContractAtFromArtifact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(hre, artifact, address, signer) {\n    var factory, contract;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (isArtifact(artifact)) {\n              _context9.next = 2;\n              break;\n            }\n\n            throw new plugins_1.NomicLabsHardhatPluginError(pluginName, \"You are trying to create a contract by artifact, but you have not passed a valid artifact parameter.\");\n\n          case 2:\n            _context9.next = 4;\n            return getContractFactoryByAbiAndBytecode(hre, artifact.abi, \"0x\", signer);\n\n          case 4:\n            factory = _context9.sent;\n            contract = factory.attach(address); // If there's no signer, we connect the contract instance to the provider for the selected network.\n\n            if (contract.provider === null) {\n              contract = contract.connect(hre.ethers.provider);\n            }\n\n            return _context9.abrupt(\"return\", contract);\n\n          case 8:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _getContractAtFromArtifact.apply(this, arguments);\n}\n\nexports.getContractAtFromArtifact = getContractAtFromArtifact; // This helper adds a `gas` field to the ABI function elements if the network\n// is set up to use a fixed amount of gas.\n// This is done so that ethers doesn't automatically estimate gas limits on\n// every call.\n\nfunction addGasToAbiMethodsIfNecessary(networkConfig, abi) {\n  var _require2 = require(\"ethers\"),\n      BigNumber = _require2.BigNumber;\n\n  if (networkConfig.gas === \"auto\" || networkConfig.gas === undefined) {\n    return abi;\n  } // ethers adds 21000 to whatever the abi `gas` field has. This may lead to\n  // OOG errors, as people may set the default gas to the same value as the\n  // block gas limit, especially on Hardhat Network.\n  // To avoid this, we substract 21000.\n  // HOTFIX: We substract 1M for now. See: https://github.com/ethers-io/ethers.js/issues/1058#issuecomment-703175279\n\n\n  var gasLimit = BigNumber.from(networkConfig.gas).sub(1000000).toHexString();\n  var modifiedAbi = [];\n\n  var _iterator = _createForOfIteratorHelper(abi),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var abiElement = _step.value;\n\n      if (abiElement.type !== \"function\") {\n        modifiedAbi.push(abiElement);\n        continue;\n      }\n\n      modifiedAbi.push(Object.assign(Object.assign({}, abiElement), {\n        gas: gasLimit\n      }));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return modifiedAbi;\n}\n\nfunction linkBytecode(artifact, libraries) {\n  var bytecode = artifact.bytecode; // TODO: measure performance impact\n\n  var _iterator2 = _createForOfIteratorHelper(libraries),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _step2.value,\n          sourceName = _step2$value.sourceName,\n          libraryName = _step2$value.libraryName,\n          address = _step2$value.address;\n      var linkReferences = artifact.linkReferences[sourceName][libraryName];\n\n      var _iterator3 = _createForOfIteratorHelper(linkReferences),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _step3.value,\n              start = _step3$value.start,\n              length = _step3$value.length;\n          bytecode = bytecode.substr(0, 2 + start * 2) + address.substr(2) + bytecode.substr(2 + (start + length) * 2);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return bytecode;\n}","map":null,"metadata":{},"sourceType":"script"}